%!

<<
/cached { % 1->proc->1
  1 dict begin /proc exch def
    /cache 1 dict def
    ({//cache 1 index known
        {//cache exch get}
        {//cache /_arg 2 index put //proc exec //cache dup /_arg get 2 index put}
        ifelse }) cvx exec
  end
}
/cached2 { % 2->proc->1
  1 dict begin /proc exch def
    /cache 1 dict def
    ({//cache 1 index known
       {//cache 1 index get 2 index 2 copy known
         {get 3 1 roll pop pop}
         {pop pop 2 copy 2 array astore //cache /_args 3 2 roll put //proc exec
           //cache dup /_args get 1 get get //cache /_args get 0 get 2 index put}
         ifelse }
       {2 copy 2 array astore //cache /_args 3 2 roll put //proc exec
         <<//cache /_args get 0 get 2 index>> //cache dup /_args get 1 get 3 2 roll put}
       ifelse }) cvx exec
  end
}
/amap { % array proc  .  array'  % in-place map mutates the array
  exch 0 1 2 index length 1 sub { % p a i
    3 copy get exch exec % p a i p_i
    3 copy put pop pop % p a'
  } for exch pop % a'
}
/map { % array proc . new-array
  [ 3 1 roll forall ]
}
/selfie { % proc . proc'  % replace occurences of SELF with proc itself
  mark 1 index
  { dup /SELF eq {pop counttomark 1 add index} if }
  amap pop pop
}
/args-begin { 1 dict begin {exch def}forall }
/first-rest { dup 0 get exch 1 1 index length 1 sub getinterval }
/fold { exch first-rest 3 2 roll forall }
/reverse{ aload 0 1 2 index length 1 sub { 3 2 roll 3 copy put pop pop } for }
/curry { /exec cvx 3 array astore cvx }
>> begin

<<
/to-each { % array proc . iterator( x=>x a[i] proc )
  1 index type /arraytype eq { to-each-array }{
      1 index type /dicttype eq { to-each-sparse }{ to-each-unit } ifelse
  } ifelse
}
/to-each-array {
    1 index length {n proc arr} args-begin
    ({//arr 0 get //proc exec SELF 1 2 copy get 1 add //n mod put})
    cvx exec selfie end
  } ifelse
} cached2
/to-each-sparse {
  {proc dict} args-begin
  ({//dict 0 2 copy known not {pop/default} if get //proc exec SELF 1 2 copy get 1 add put})
  cvx exec selfie end
}
/to-each-unit { % arg proc
  curry
}

/+= {{add} to-each amap}
/+ {{add} to-each map}
/dy {aload pop exch pop exch sub exch pop} % Y-y
/dx {aload pop pop exch pop exch sub} % X-x
/xy {aload pop pop pop}
/margin{ [1 1 -1 -1] exch {mul} curry map }
%/margin{ dup dup neg dup 4 array astore }

% divide evenly to match rows
/vert { % bounds table eachrow
  1 index length 3 1 roll divy
}

% divide evenly into n slices
/divy { % bounds n table eachrow
  4 2 roll 1 index dy exch div % t e b dy/n
  4 2 roll fixht
}

% divide off fixed-height slices, discarding the scrap slice
/fixht { % bounds ht table eachrow
  4 2 roll 3 index length 3 2 roll aload pop % table eachrow ht n bounds...
  {Y X y x n h} args-begin
  [ [ y h Y .0001 add {} for ]
    {
	[ x 4 2 roll X exch dup 6 1 roll ] exch
    } fold pop
  ] reverse
  end 3 1 roll to-each map
}

% divide evenly by number cells
/horz { % bounds row eachcell
  1 index length 3 1 roll divx
}

% divide evenly into n cells
/divx { % bounds n row eachcell
    4 2 roll 1 index dx exch div 4 2 roll fixwd
}

% divide off fixed-width cells, discarding the scrap slice
/fixwd { % bounds wd row eachcell
  4 2 roll 3 index length 3 2 roll aload pop
  {Y X y x n w} args-begin
    [ [ x w X .0001 add {} for ]
      { [ 3 1 roll y exch Y 1 index 6 1 roll ] exch } fold pop
    ]
  end 3 1 roll to-each map
}

% stub for typesetting in a region
/placetext {
  1 index xy 3 index dx 4 index dy rectstroke
  exch dup dx .05 mul 0 1 index neg 0 4 array astore + exch
  1 index xy 3 index dy .18 mul add moveto
  /Helvetica 18 selectfont
  show pop
}

% stretch/shrink to fit text (nicely?) in the region.
% intended for short strings like tags or labels.
% text shown in color with a hack-y outline effect
/zoomshow { % bounds str
  2 copy == == / =
  1 index xy 3 index dx 4 index dy rectstroke
  exch dup dx .05 mul 0 1 index neg 0 4 array astore + exch
  /Helvetica-Bold 2 index dy .9 mul selectfont
  1 index xy 3 index dy .18 mul add moveto
  dup stringwidth pop % b s sw_x
  2 index dx % b s sw_x dx
  2 copy gt { % sw_x dx
    (shrink) =
    exch div 1 matrix scale dup ==
    currentfont exch makefont setfont
    0 0
  } if pop pop
  %show
  gsave
    gsave .7 .2 .5 setrgbcolor dup show grestore
    [1] 0 setdash
    %currentlinewidth 1.5 mul setlinewidth
    0 setlinejoin 1 setmiterlimit
    0 setlinecap
    false charpath strokepath stroke
  grestore
}

%failed attempt to "bake in" the vertical centering into the font
%in order to streamline the code in zoomshow
/selectshiftedfont {
  {sz fn}args-begin
    /fn fn findfont def
    /h fn /FontBBox get 1 get abs def
    fn [ 1 0 0 1 0 h
	%1000 div
	fn /FontMatrix get dtransform
       ] dup ==
       makefont sz scalefont setfont
  end
}

%Formatters

/gridshow {
    {
	exch 5 margin + exch
	{ exch 5 margin + exch zoomshow } horz
    } vert
}

/labels {
    1.254 72 mul exch
    {
	2 72 mul exch { exch 5 margin + exch zoomshow } fixwd
    } fixht
}

/tags {
    1.314 72 mul exch {
	{ exch 5 margin + exch zoomshow } horz
    } fixht
}

/fourby {
    4 exch {
	{ exch 5 margin + exch zoomshow } horz
    } divy
}

/byfour {
    {
	4 exch { exch 5 margin + exch zoomshow } divx
    } vert
}

/fourbysix {
    4 exch {
	6 exch { exch 5 margin + exch zoomshow } divx
    } divy
}

% we pass data into the eachcell proc from the eachrow proc by currying
% the data and the proc into a new proc and using that one.
/nbym {
    { exch { exch 5 margin + exch zoomshow } divx } curry
    exch 3 1 roll divy
}

/layout {
    { exch { exch 5 margin + exch placetext } divx } curry
    exch 3 1 roll divy
}
>> begin

/EXAMPLE where {pop}{currentfile flushfile} ifelse

[ 6 3 2 3 ] 3 setdash
/length { dup (hot potato) eq { pop 4 }{ length } ifelse } bind def

%[0 0 612 792]
[0 0 792 612] 0 792 translate -90 rotate
18 margin +

 % data is accessed cyclically to match regions shape.
 % to-each constructor is memo-ized so subsequent instantiations
 % will continue in sequence where the previous one left off
[
  [
    (Cured Meats) (Overstock) (Dairy)        (Pork)        (Poultry)
    (Beef)        (Produce)   (Pizza Crusts) (Burger Buns) (Hot Dog Buns)
  ]
  <<
    0(pull from right) 10 1 index
    1(use shelves first)     %only pairs with the first occurence of Overstock
    11 1 index               %unless we do this too
    /default(pull from left)
  >>
]
pop
[
 [(duck)(duck)(goose)]
 [(rock)(paper)(scissors)]
 (hot potato)  % one-value reused for the whole row
]
%pop
pstack/ =
%gridshow  % divide evenly to match data
%labels    % divide-off fixed-height, fixed-width cells
%tags      % fixed height, rows to match data
%fourby    % four rows of whatever divided evenly
%byfour    % evenly divide by data rows, 4 cells per row
%fourbysix % four rows of six cells
8 4 nbym % n rows of m cells
%3 3 nbym
%4 8 layout

pstack/ =
showpage
