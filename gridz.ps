%!

<<
/cached { % 1->proc->1
  1 dict begin /proc exch def
    /cache 1 dict def
    ({//cache 1 index known
        {//cache exch get}
        {//cache /_arg 2 index put //proc exec //cache dup /_arg get 2 index put}
        ifelse }) cvx exec
  end
}
/cached2 { % 2->proc->1
  1 dict begin /proc exch def
    /cache 1 dict def
    ({//cache 1 index known
       {//cache 1 index get 2 index 2 copy known
         {get 3 1 roll pop pop}
         {pop pop 2 copy 2 array astore //cache /_args 3 2 roll put //proc exec
           //cache dup /_args get 1 get get //cache /_args get 0 get 2 index put}
         ifelse }
       {2 copy 2 array astore //cache /_args 3 2 roll put //proc exec
         <<//cache /_args get 0 get 2 index>> //cache dup /_args get 1 get 3 2 roll put}
       ifelse }) cvx exec
  end
}
/amap { % array proc  .  array'  % in-place map mutates the array
  exch 0 1 2 index length 1 sub { % p a i
    3 copy get exch exec % p a i p_i
    3 copy put pop pop % p a'
  } for exch pop % a'
}
/map { % array proc . new-array
  [ 3 1 roll forall ]
}
/selfie { % proc . proc'  % replace occurences of SELF with proc itself
  mark 1 index
  { dup /SELF eq {pop counttomark 1 add index} if }
  amap pop pop
}
/args-begin { 1 dict begin {exch def}forall }
/first-rest { dup 0 get exch 1 1 index length 1 sub getinterval }
/fold { exch first-rest 3 2 roll forall }
/reverse{ aload 0 1 2 index length 1 sub { 3 2 roll 3 copy put pop pop } for }
/curry { /exec cvx 3 array astore cvx }
>> begin

<<
/to-each { % array|dict|string proc . iterator( x=>x a[i] proc )
  1 index type /arraytype eq { to-each-array }{
      1 index type /dicttype eq { to-each-sparse }{ to-each-unit } ifelse
  } ifelse
} cached2
/to-each-array {
  1 index length {n proc arr} args-begin
  ({//arr 0 get //proc exec SELF 1 2 copy get 1 add //n mod put})
  cvx exec selfie end
}
/to-each-sparse {
  {proc dict} args-begin
  ({//dict 0 2 copy known not {pop/default} if get //proc exec SELF 1 2 copy get 1 add put})
  cvx exec selfie end
}
/to-each-unit { % arg proc
  curry
}

/+= {{add} to-each amap}
/+ {{add} to-each map}
/dy {aload pop exch pop exch sub exch pop} % Y-y
/dx {aload pop pop exch pop exch sub} % X-x
/xy {aload pop pop pop}
/margin{ [1 1 -1 -1] exch {mul} curry map }
/vmargin{ [0 1 0 -1] exch {mul} curry map }
/hmargin{ [1 0 -1 0] exch {mul} curry map }
/tmargin{ [0 0 0 -1] exch {mul} curry map }
/bmargin{ [0 1 0 0] exch {mul} curry map }
/lmargin{ [1 0 0 0] exch {mul} curry map }
/rmargin{ [0 0 -1 0] exch {mul} curry map }
/margin+{ margin + }


% draw box around the region
/rect { % bounds
  dup xy 2 index dx 3 index dy rectstroke pop
}

% divide evenly to match rows
/vert { % bounds table eachrow
  1 index length 3 1 roll divy
}

% divide evenly into n slices
/divy { % bounds n table eachrow
  4 2 roll 1 index dy exch div % t e b dy/n
  4 2 roll fixht
}

% divide off fixed-height slices, discarding any scrap slice
/fixht { % bounds ht table eachrow
  4 2 roll 3 index length 3 2 roll aload pop % table eachrow ht n bounds...
  {Y X y x n h} args-begin
  [ [ Y h neg y .0001 sub {} for ]
    %[ y h Y .0001 add {} for ]
    {
	%[ x 4 2 roll      X exch dup     6 1 roll ] exch
	[ x 4 2 roll exch X exch 2 index 6 1 roll ] exch
    } fold pop
  ] %reverse
  end 3 1 roll to-each map
}

% divide evenly by number cells
/horz { % bounds row eachcell
  1 index length 3 1 roll divx
}

% divide evenly into n cells
/divx { % bounds n row eachcell
    4 2 roll 1 index dx exch div 4 2 roll fixwd
}

% divide off fixed-width cells, discarding any scrap slice
/fixwd { % bounds wd row eachcell
  4 2 roll 3 index length 3 2 roll aload pop
  {Y X y x n w} args-begin
    [ [ x w X .0001 add {} for ]
      { [ 3 1 roll y exch Y 1 index 6 1 roll ] exch } fold pop
    ]
  end 3 1 roll to-each map
}

% stretch/shrink to fit text (nicely?) in the region.
% intended for short strings like tags or labels.
% text shown in color with a hack-y outline effect
/zoomshow { % bounds str
  2 copy == == / =
  exch dup dx .05 mul hmargin +
       5 margin+ exch
  /Helvetica-Bold 2 index dy .9 mul selectfont
  1 index xy 3 index dy .18 mul add moveto
  dup stringwidth pop % b s sw_x
  2 index dx % b s sw_x dx
  2 copy gt { % sw_x dx
    (shrink) =
    exch div 1 matrix scale dup ==
    currentfont exch makefont setfont
    0 0
  } if pop pop
  %show
  gsave
    gsave .7 .2 .5 setrgbcolor dup show grestore
    [1] 0 setdash
    %currentlinewidth 1.5 mul setlinewidth
    0 setlinejoin 1 setmiterlimit
    0 setlinecap
    false charpath strokepath stroke
  grestore
}

% stub for typesetting in a region
/placetext {
  %1 index xy 3 index dx 4 index dy rectstroke
  exch dup dx .05 mul 0 1 index neg 0 4 array astore + exch
  1 index xy 3 index dy .18 mul add moveto
  /Palatino-Roman 14 selectfont
  show pop
}

%Formatters  region data (opt-args) formatter

/gridshow { % region data
    { { zoomshow } horz } vert
}

/labels { % region data
    72 exch {
      2.625 72 mul exch { exch dup rect exch zoomshow } fixwd
    } fixht
}

/tags { % region data
    1.314 72 mul exch {
	{ exch dup rect exch zoomshow } horz
    } fixht
}

/fourby { % region data
    4 exch { { exch dup rect exch zoomshow } horz } divy
}

/byfour { % region data
    { 4 exch { exch dup rect exch zoomshow } divx } vert
}

/fourbysix { % region data
    4 exch { 6 exch { exch dup rect exch zoomshow } divx } divy
}

/nbym { % region data n m   % we pass data into the eachcell proc from the eachrow proc by currying
    { exch { exch dup rect exch zoomshow } divx } curry
    exch 3 1 roll divy
}

/addresses {
    10 exch { 3 exch { exch 4.5 hmargin + dup rect
		       4.5 vmargin + exch 4 exch
		       { placetext } divy } divx } divy
}

/shelves {
    5 exch {
	exch 5 vmargin + dup rect exch
	2 exch {
	    2 exch {
		exch dup rect exch
		zoomshow
	    } divy
        } divx
    } divy
}

/layout { % region data n m 
    { exch { exch dup rect exch placetext } divx } curry
    exch 3 1 roll divy
}
>> begin

/EXAMPLE where {pop}{currentfile flushfile} ifelse

[ 6 3 2 3 ] 3 setdash
/length { dup (hot potato) eq { pop 4 }{ length } ifelse } bind def

[0 0 792 612] 0 792 translate -90 rotate
%[0 0 612 792]
36 vmargin +   % 1/2 inch top and bottom for Avery labels
9 hmargin + % 3/16 inch left and right for Avery labels -1/16 internal hmargin

 % data is accessed cyclically to match regions shape.
 % to-each constructor is memo-ized so subsequent instantiations
 % will continue in sequence where the previous one left off
[[[
    %(Overstock)(Use Shelves First)
    (Cured Meats)(Pull From Right) 
    %(Burger Buns)(Pull From Right) 
    %(Hot Dog Buns)(Pull From Right)
    (Dairy)(Pull From Left)        
    %(Pork)(Pull From Left)        
    %(Poultry)(Pull From Left)
    %(Beef)(Pull From Left)        
    (Pretzels)(Pull From Left)
    (Pizza Crusts)(Pull From Left) 
    (Produce)(Pull From Left)   
]]]
pop


[
 <</default(duck)2(goose)[7 11]{1 index}forall>>
 [(rock)(paper)(scissors)]
 (hot potato)  % one-value reused for the whole row ^^override length to set number
]
%pop

[[[
(Name)(123 Streetname)(Apt 42)(City, ST 54321)
(Other name)(456 Other Street)(Basement)(City, ST 54321)
]]]
pop

pstack/ =
%gridshow  % divide evenly to match data
%labels    % divide-off fixed-height, fixed-width cells (Avery 5160 labels 2.625x1 inch)
%tags      % fixed height, rows to match data
%fourby    % four rows of whatever divided evenly
%byfour    % evenly divide by data rows, 4 cells per row
%fourbysix % four rows of six cells
10 3 nbym % n rows of m cells (Avery 5160 labels 10 x 3 per sheet)
%3 3 nbym
%addresses  % 10x3 x 4 lines for Avery 5160 address labels
%shelves
%4 8 layout

pstack/ =
showpage
